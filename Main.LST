C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\Output\Main.obj
COMPILER INVOKED BY: C:\Users\lyxso\System\Tools\Keil\C51\BIN\C51.EXE Main.c ROM(COMPACT) INCDIR(C:\Users\lyxso\System\T
                    -ools\Keil\C51\INC\) OBJECT(..\Output\Main.obj)

line level    source

   1          /*
   2                  (*)     Clock
   3          
   4                          LyxSoft 13.10.2015
   5          
   6          */
   7          
   8          #include "STC\STC15F104E.H"
   9          #include "DS1302.h"
  10          #include "NTC.h"
  11          
  12          /*                                      0    1    2        3    4        5        6        7    8        9    A    b    C    d    E    F  
             -  G    H    I    J         L         N    O    P    q    r    S    t    U    V    W         y    Z    [    \    ]
  13                                                                                                                                                                                                                                                                                                                                                                                                                                                            DEG    -       8.
  14                                                  0    1    2    3    4    5    6    7    8    9   10   11   12   13
             -   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33   34   35   36   37
             -   38  39*/
  15          
  16          unsigned char code tblNumbers[]    ={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0x88,0x83,0xC6,0xA1
             -,0x86,0x8E,0xC2,0x89,0xF9,0xF1,0xFF,0xC7,0xFF,0xC8,0xC0,0x8C,0x98,0xAF,0x92,0x87,0xC1,0x8D,0x81,0xFF,0x91,0xA4,0x9C,0xBF
             -,0x0,0xFF};
  17          unsigned char code tblNumbersRev[] ={0xC0,0xCF,0xA4,0x86,0x8B,0x92,0x90,0xC7,0x80,0x82,0x81,0x98,0xF0,0x8C
             -,0xB0,0xB1,0xD0,0x89,0xCF,0xCE,0xFF,0xF8,0xFF,0xC1,0xC0,0xA1,0x83,0xBD,0x92,0xB8,0xC8,0xA9,0x88,0xFF,0x8A,0xA4,0xA3,0xBF
             -,0x0,0xFF};
  18          
  19          //                                                                      Mon                                     TUE                                      WEd                             Thu                             Fri                             SAt                             Sun
  20          //                                      n        o        N        |,   E        U        T        T,   d        E        U    |,       u        h    T    T,   i
             -         r          F             ,t               A        S             ,       n
  21          unsigned char code tblWeek[]       ={0xAB,0xA3,0xC8,0xF9,0x86,0xC1,0xCE,0xFE,0xA1,0x86,0xC1,0xF9,0xE3,0x8B
             -,0xCE,0xFE,0xFB,0xAF,0x8E,0xFF,0x87,0x88,0x92,0xFF,0xAB,0xE3,0x92,0xFF};
  22          unsigned char code tblWeekRev[]    ={0x9D,0x9C,0xC1,0xCF,0xB0,0xC8,0xF1,0xF7,0x8C,0xB0,0xC8,0xCF,0xDC,0x99
             -,0xF1,0xF7,0xDF,0xBD,0xB1,0xFF,0xB8,0x81,0x92,0xFF,0x9D,0xDC,0x92,0xFF};
  23          /*                                      0    1    2        3    4        5        6        7    8        9    a    b    c    d    e    f  
             - 10   11   12*/
  24          unsigned char code tblMonthDays[] = {0x00,0x31,0x28,0x31,0x30,0x31,0x30,0x31,0x31,0x30,0x00,0x00,0x00,0x00
             -,0x00,0x00,0x31,0x30,0x31};
  25          
  26          #define MAKEBCD(nValue) ((((nValue) / 10) << 4) + ((nValue) % 10))
  27          #define GETBCD(nBCD)    ((((nBCD) >> 4) * 10) + ((nBCD) & 0xF))
  28          
  29          #define KEY_S1  P31
  30          #define KEY_S2  P30
  31          #define KEY_OK  P30
  32          #define KEY_SYNC P30
  33          
  34          #define BEEP    P33
  35          
  36          #define MODE_CLOCK              0
  37          #define MODE_HOUR               1
  38          #define MODE_MINUTE             2
  39          #define MODE_HOUR24             3
  40          #define MODE_MONTH              4
  41          #define MODE_DAY                5
  42          #define MODE_WEEK               6
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 2   

  43          #define MODE_YEAR               7
  44          #define MODE_BEEP               8
  45          #define MODE_ALARM_H    9
  46          #define MODE_ALARM_M    10
  47          #define MODE_UP                 11
  48          #define MODE_NIGHT              12
  49          #define MODE_MAX                12
  50          
  51          #define SMODE_CLOCK                             0
  52          #define SMODE_TEMP                              1
  53          #define SMODE_DATE                              2
  54          #define SMODE_WEEK                              3
  55          #define SMODE_YEAR                              4
  56          #define SMODE_SECOND                    5
  57          #define SMODE_MS                                6
  58          #define SMODE_COUNTDOWN1                7
  59          #define SMODE_COUNTDOWN2                8
  60          #define SMODE_ALARM                             9
  61          #define SMODE_MAX                               9
  62          
  63          #define SMODE_COUNTSEC                  10      //10 seconds return to SMODE_CLOCK
  64          
  65          #define DMODE_CLOCK                             1
  66          #define DMODE_DIGDOT                    2
  67          #define DMODE_DEGDOT                    3
  68          #define DMODE_DEGMIN                    4
  69          #define DMODE_DATE                              5
  70          
  71          #define DMODE_FLAG_PM                           0x10
  72          
  73          bit bBlockClock;
  74          
  75          // Clock
  76          static DS1302Time nCurrentTime; 
  77          static unsigned char n100Ms, n10Ms, nMs;
  78          static bit bBeep, bUp, bNightMode;
  79          static unsigned char nAlarmH, nAlarmM;
  80          
  81          // Temperature
  82          static unsigned char nTemp, nTempL;
  83          
  84          // Buttons
  85          static bit bPressedS1, bPressedS2;
  86          
  87          static bit bNight, bSleep;
  88          static unsigned char nMode, nSubMode, nSubModeTime, nCountDownSec, nCountDownMin, nCountDownBeep;
  89          
  90          // Display
  91          static unsigned char nLED, nData0, nData1, nData2, nData3, nShow;
  92          static bit bDot, bSound; //, bShow0, bShow1, bShow2, bShow3;
  93          
  94          
  95          unsigned char BCDHour24 (unsigned char nBCD)
  96          {
  97   1              if (nBCD & 0x80)        // 12 HOUR
  98   1              {
  99   2                      if ((nBCD & 0xA0) == 0xA0)      //PM
 100   2                      {
 101   3                              nBCD = GETBCD (nBCD & 0x1F);
 102   3                              if (nBCD != 12) //12 PM means 12 aclock
 103   3                                      nBCD += 12;
 104   3                              return (MAKEBCD (nBCD));
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 3   

 105   3                      }
 106   2                      else                                            //AM
 107   2                      {
 108   3                              nBCD &= 0x1F;
 109   3                              if (nBCD == 0x12)               //12 AM means 0 aclock
 110   3                                      return (0);
 111   3                      }
 112   2              }
 113   1              return (nBCD);
 114   1      }
 115          
 116          unsigned char BCDHour12 (unsigned char nBCD)
 117          {
 118   1              if (nBCD & 0x80)        // 12 HOUR
 119   1                      return (nBCD);
 120   1      
 121   1              if (nBCD >= 0x12)                       //PM
 122   1              {
 123   2                      nBCD = GETBCD (nBCD) - 12;
 124   2                      if (nBCD == 0)
 125   2                              return (0xB2);          //12 PM
 126   2                      else
 127   2                              return (0xA0 | MAKEBCD (nBCD));
 128   2              }
 129   1              else if (nBCD == 0)
 130   1                      return (0x92);                  // 12 AM
 131   1              else
 132   1                      return (0x80 | nBCD);
 133   1      }
 134          
 135          //#define CHARINDEX(nChar) (nChar <= '9' ? (nChar-'9'):(nChar <= ']' ? (nChar-'A'+10):(nChar <= 'z' ? (nCh
             -ar-'a'+10):0xFF)))
 136          unsigned char CharIndex (unsigned char nChar)
 137          {
 138   1              if (nChar <= '9')
 139   1                      return (nChar - '0');
 140   1              if (nChar <= ']')
 141   1                      return (nChar - 'A' + 10);
 142   1              if (nChar <= 'z')
 143   1                      return (nChar - 'a' + 10);
 144   1              return 39; //NA
 145   1      }
 146          
 147          void DisplayChar (unsigned char nChar0, unsigned char nChar1, unsigned char nChar2, unsigned char nChar3)
 148          {
 149   1              if (bUp)
 150   1              {
 151   2                      nData0 = tblNumbers [CharIndex(nChar0)];
 152   2                      nData1 = tblNumbersRev [CharIndex(nChar1)];
 153   2                      nData2 = tblNumbers [CharIndex(nChar2)];
 154   2                      nData3 = tblNumbers [CharIndex(nChar3)];
 155   2              }
 156   1              else
 157   1              {
 158   2                      nData3 = tblNumbersRev [CharIndex(nChar0)];
 159   2                      nData2 = tblNumbersRev [CharIndex(nChar1)];
 160   2                      nData1 = tblNumbers [CharIndex(nChar2)];
 161   2                      nData0 = tblNumbersRev [CharIndex(nChar3)];
 162   2              }
 163   1      }
 164          
 165          void DisplayDecNum (unsigned char nNumLow, unsigned char nNumHigh, unsigned char nMode)
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 4   

 166          {
 167   1              if (bUp)
 168   1              {
 169   2                      nData0 = tblNumbers [nNumLow & 0xF];
 170   2                      nData1 = tblNumbersRev [nNumLow >> 4];
 171   2                      nData2 = tblNumbers [nNumHigh & 0xF];
 172   2                      nData3 = tblNumbers [nNumHigh >> 4];
 173   2              }
 174   1              else
 175   1              {
 176   2                      nData3 = tblNumbersRev [nNumLow & 0xF];
 177   2                      nData2 = tblNumbersRev [nNumLow >> 4];
 178   2                      nData1 = tblNumbers [nNumHigh & 0xF];
 179   2                      nData0 = tblNumbersRev [nNumHigh >> 4];
 180   2              }
 181   1              switch (nMode & 0xF)
 182   1              {
 183   2              case DMODE_CLOCK:                                 //:
 184   2                      nData1 &= 0x7F;
 185   2                      nData2 &= 0x7F;
 186   2                      break;
 187   2              case DMODE_DIGDOT:                                //.
 188   2                      if (bUp)
 189   2                              nData2 &=0x7F;
 190   2                      else
 191   2                              nData1 &=0x7F;
 192   2                      break;
 193   2              case DMODE_DEGDOT:                               //.Deg
 194   2                      if (bUp)
 195   2                      {
 196   3                              nData0 = 0x9c;   //Deg
 197   3                              nData2 &=0x7F;
 198   3                      }
 199   2                      else
 200   2                      {
 201   3                              nData3 = 0xA3;   //Deg
 202   3                              nData1 &=0x7F;
 203   3                      }
 204   2                      break;
 205   2              case DMODE_DEGMIN:                              //- Deg
 206   2                      if (bUp)
 207   2                      {
 208   3                              nData0 = 0x9c;   //Deg
 209   3                              nData3 = 0xBF;   //-
 210   3                      }
 211   2                      else
 212   2                      {
 213   3                              nData3 = 0xA3;   //Deg
 214   3                              nData1 = 0xBF;   //-
 215   3                      }
 216   2                      break;
 217   2              case DMODE_DATE:                                  //'
 218   2                      if (bUp)
 219   2                              nData1 &=0x7F;
 220   2                      else
 221   2                              nData2 &=0x7F;
 222   2                      break;
 223   2              default:
 224   2                      break;
 225   2              }
 226   1              if (nMode & DMODE_FLAG_PM)                       //' @ End
 227   1              {
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 5   

 228   2                      if (bUp)
 229   2                              nData0 &=0x7F;
 230   2                      else
 231   2                              nData3 &=0x7F;
 232   2              }
 233   1      }
 234          
 235          void DisplayErr (void)
 236          {
 237   1              nData0 = 0;
 238   1              nData1 = nData0;
 239   1              nData2 = nData0;
 240   1              nData3 = nData0;
 241   1      }
 242          
 243          void PreDisplay (void)
 244          {
 245   1              unsigned char nDisplay;
 246   1              unsigned char nShowMaskH, nShowMaskL;
 247   1      
 248   1              nShowMaskH = bUp ? 0xC : 0x3;
 249   1              nShowMaskL = bUp ? 0x3 : 0xC;
 250   1              nShow = 0xF; //Show All
 251   1              switch (nMode)
 252   1              {
 253   2              case MODE_CLOCK:
 254   2                      nDisplay = nSubMode;
 255   2                      break;
 256   2      
 257   2              case MODE_HOUR:
 258   2                      if (!bPressedS1 && !bDot)
 259   2                              nShow = nShowMaskL; //bUp ? 0x3 : 0xC;
 260   2      
 261   2                      nDisplay = SMODE_CLOCK;
 262   2                      break;
 263   2              case MODE_MINUTE:
 264   2                      if (!bPressedS1 && !bDot)
 265   2                              nShow = nShowMaskH; //bUp ? 0xC : 0x3;
 266   2      
 267   2                      nDisplay = SMODE_CLOCK;
 268   2                      break;
 269   2              case MODE_MONTH:
 270   2                      if (!bPressedS1 && !bDot)
 271   2                              nShow = nShowMaskL; //bUp ? 0x3 : 0xC;
 272   2      
 273   2                      nDisplay = SMODE_DATE;
 274   2                      break;
 275   2              case MODE_DAY:
 276   2                      if (!bPressedS1 && !bDot)
 277   2                              nShow = nShowMaskH; //bUp ? 0xC : 0x3;
 278   2      
 279   2                      nDisplay = SMODE_DATE;
 280   2                      break;
 281   2              case MODE_WEEK:
 282   2                      if (!bPressedS1 && !bDot)
 283   2                              nShow = 0;
 284   2      
 285   2                      nDisplay = SMODE_WEEK;
 286   2                      break;
 287   2              case MODE_YEAR:
 288   2                      if (!bPressedS1 && !bDot)
 289   2                              nShow = 0;
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 6   

 290   2      
 291   2                      nDisplay = SMODE_YEAR;
 292   2                      break;
 293   2              case MODE_ALARM_H:
 294   2                      if (!bPressedS1 && !bDot)
 295   2                              nShow = nShowMaskL; //bUp ? 0x3 : 0xC;
 296   2      
 297   2                      nDisplay = SMODE_ALARM;
 298   2                      break;
 299   2              case MODE_ALARM_M:
 300   2                      if (!bPressedS1 && !bDot)
 301   2                              nShow = nShowMaskH; //bUp ? 0xC : 0x3;
 302   2      
 303   2                      nDisplay = SMODE_ALARM;
 304   2                      break;
 305   2              case MODE_HOUR24:
 306   2                      if (!bPressedS1 && !bDot)
 307   2                              nShow = 0;
 308   2                      else
 309   2                              nShow = bUp ? 0x7 : 0xE;
 310   2                      
 311   2                      if (nCurrentTime.Hour & 0x80)   // 12 HOUR
 312   2                              DisplayChar ('H','2','1',0xFF);
 313   2                      else
 314   2                              DisplayChar ('H','4','2',0xFF);
 315   2                      return;
 316   2              case MODE_BEEP:
 317   2                      if (!bPressedS1 && !bDot)
 318   2                              nShow = 0;
 319   2                      
 320   2                      if (bBeep)
 321   2                              DisplayChar ('P','E','E','B');
 322   2                      else
 323   2                              DisplayChar ('\\','\\','\\','\\');
 324   2                      return;
 325   2              case MODE_UP:
 326   2                      if (!bPressedS1 && !bDot)
 327   2                              nShow = 0;
 328   2                      
 329   2                      DisplayChar ('P','U',0xFF,0xFF);
 330   2                      return;
 331   2              case MODE_NIGHT:
 332   2                      if (bNightMode)
 333   2                              DisplayChar ('N','O',0xFF,'N');
 334   2                      else
 335   2                              DisplayChar ('F','F','O','N');
 336   2                      return;         
 337   2              default:
 338   2                      if (!bPressedS1 && !bDot)
 339   2                              nShow = 0;
 340   2      
 341   2                      DisplayErr (); //DisplayChar (']',']',']',']'); //NA
 342   2                      return;         
 343   2              }
 344   1      
 345   1              switch (nDisplay)
 346   1              {
 347   2              case SMODE_CLOCK:
 348   2                      nData2 = nCurrentTime.Hour;
 349   2      
 350   2                      if (nData2 & 0x80) //12 Hour mode
 351   2                      {
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 7   

 352   3                              nData2 &= 0x1F;
 353   3                              if (nData2 < 0x10)
 354   3                                      nShow &= bUp ? 0x7 : 0xE;
 355   3                      }
 356   2      
 357   2                      DisplayDecNum (nCurrentTime.Minute, nData2, (unsigned char)bDot | (((nCurrentTime.Hour & 0xA0) == 0xA0) 
             -? DMODE_FLAG_PM : 0));        //12 Hour Mode and PM
 358   2      
 359   2                      break;
 360   2              case SMODE_TEMP:
 361   2                      if (nTemp >= 40 && nTempL < 10)
 362   2                              DisplayDecNum (nTempL << 4, MAKEBCD(nTemp-40), DMODE_DEGDOT);
 363   2                      else if (nTemp < 40)
 364   2                      {
 365   3                              nData0 = 40 - nTemp;
 366   3                              DisplayDecNum ((nData0%10)<<4, nData0/10, DMODE_DEGMIN);
 367   3                      }
 368   2                      else
 369   2                      {
 370   3                              DisplayErr ();
 371   3                      }
 372   2                      break;
 373   2      
 374   2              case SMODE_DATE:
 375   2                      DisplayDecNum (nCurrentTime.Day, nCurrentTime.Month, DMODE_DATE);
 376   2                      if (nCurrentTime.Month < 0x10)
 377   2                              nShow &= bUp ? 0x7 : 0xE;
 378   2                      break;
 379   2      
 380   2              case SMODE_WEEK:
 381   2                      if (nCurrentTime.Week <= 7 && nCurrentTime.Week >= 1)
 382   2                      {
 383   3                              unsigned char nPtr;
 384   3      
 385   3                              nPtr = nCurrentTime.Week * 4 - 4;
 386   3                              if (bUp)
 387   3                              {
 388   4                                      nData0 = tblWeek [nPtr];
 389   4                                      nData1 = tblWeekRev [nPtr + 1]; 
 390   4                                      nData2 = tblWeek [nPtr + 2];    
 391   4                                      nData3 = tblWeek [nPtr + 3];    
 392   4                              }
 393   3                              else
 394   3                              {
 395   4                                      nData3 = tblWeekRev [nPtr];
 396   4                                      nData2 = tblWeekRev [nPtr + 1]; 
 397   4                                      nData1 = tblWeek [nPtr + 2];    
 398   4                                      nData0 = tblWeekRev [nPtr + 3]; 
 399   4                              }
 400   3                      }
 401   2                      break;
 402   2              case SMODE_YEAR:
 403   2                      DisplayDecNum (nCurrentTime.Year, 0x20, 0); 
 404   2                      break;
 405   2              case SMODE_SECOND:
 406   2                      DisplayDecNum (nCurrentTime.Second, nCurrentTime.Minute, bDot); 
 407   2                      break;
 408   2              case SMODE_MS:
 409   2                      DisplayDecNum (n100Ms<<4, nCurrentTime.Second, DMODE_DIGDOT);
 410   2                      break;
 411   2              case SMODE_COUNTDOWN1:
 412   2                      DisplayDecNum (MAKEBCD(nCountDownSec), MAKEBCD(nCountDownMin), DMODE_CLOCK);
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 8   

 413   2                      break;
 414   2              case SMODE_COUNTDOWN2:
 415   2                      DisplayDecNum (MAKEBCD(nCountDownSec), MAKEBCD(nCountDownMin), (nCountDownBeep == 0 || bDot));
 416   2                      break;
 417   2              case SMODE_ALARM:
 418   2                      DisplayDecNum (nAlarmM, nAlarmH, DMODE_CLOCK | DMODE_FLAG_PM);
 419   2                      break;
 420   2              default:
 421   2                      DisplayErr ();
 422   2                      break;
 423   2              }
 424   1      
 425   1              nDisplay = BCDHour24(nCurrentTime.Hour);
 426   1              bNight = nDisplay >= 0x20 || nDisplay <= 0x6;
 427   1              bSleep = nDisplay >= 0x21 || nDisplay <= 0x5;
 428   1      }
 429          
 430          void OnTimer () interrupt 1
 431          {
 432   1              static unsigned char nLastSec;
 433   1              static unsigned char nShowCount = 0;
 434   1                      
 435   1              // Timer reset
 436   1              TL0 = 0xD7; //0xCD;
 437   1              TH0 = 0xFD; //0xD4;                     // 0.05ms
 438   1      
 439   1              // Clock
 440   1              nMs ++;
 441   1              nShowCount ++;
 442   1              if (nMs >= 200)
 443   1              {
 444   2                      nMs = 0;
 445   2                      n10Ms ++;
 446   2      
 447   2                      if (n10Ms >= 10)
 448   2                      {
 449   3                              n10Ms = 0;
 450   3                              n100Ms ++;
 451   3                              if (n100Ms == 5)
 452   3                              {
 453   4                                      bDot = 1;
 454   4                              }
 455   3                              else if (n100Ms >= 10)
 456   3                              {
 457   4                                      bDot = 0;
 458   4                                      n100Ms = 0;
 459   4                              }
 460   3      
 461   3                              // Close Tick Sound
 462   3                              if (bSound)
 463   3                              {
 464   4                                      if (bBeep && BEEP)
 465   4                                              BEEP = 0;
 466   4                                      else
 467   4                                      {
 468   5                                              BEEP = 1;
 469   5                                              bSound = 0;
 470   5                                      }
 471   4                              }
 472   3      
 473   3                              // Read DS1302
 474   3                              nLastSec = nCurrentTime.Second;
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 9   

 475   3              
 476   3                              if (!bBlockClock)
 477   3                                      if (!DS1302ReadTime (&nCurrentTime))    //Read Time
 478   3                                              return;
 479   3              
 480   3                              // If time is changed
 481   3                              if (nCurrentTime.Second != nLastSec)
 482   3                              {
 483   4                                      n100Ms = 0;
 484   4                                      n10Ms = 0;
 485   4                                      nMs = 0;
 486   4                                      bDot = 0;
 487   4                      
 488   4                                      if (nMode == MODE_CLOCK)
 489   4                                      {
 490   5                                              switch (nSubMode)
 491   5                                              {
 492   6                                              case SMODE_COUNTDOWN2:
 493   6                                                      if (!nCountDownSec)
 494   6                                                      {
 495   7                                                              if (nCountDownMin)
 496   7                                                              {
 497   8                                                                      nCountDownMin --;
 498   8                                                                      nCountDownSec = 59;
 499   8                                                              }
 500   7                                                              else if (nCountDownBeep)
 501   7                                                              {
 502   8                                                                      bSound = 1;
 503   8                                                                      nCountDownBeep --;
 504   8                                                              }
 505   7                                                      }
 506   6                                                      else
 507   6                                                              nCountDownSec --;
 508   6                                                      break;
 509   6                                              case SMODE_TEMP:
 510   6                                                      if (nSubModeTime)
 511   6                                                      {
 512   7                                                              nTemp = ReadTemperature (&nTempL);
 513   7                                                              nSubModeTime --;
 514   7                                                      }
 515   6                                                      else
 516   6                                                              nSubMode = SMODE_CLOCK;
 517   6                                                      break;
 518   6                                              case SMODE_CLOCK:
 519   6                                                      if (nSubModeTime)
 520   6                                                              nSubModeTime --;
 521   6                                                      break;
 522   6                                              default:
 523   6                                                      break;
 524   6                                              }
 525   5                                      }
 526   4                                      
 527   4                                      if (BCDHour24(nCurrentTime.Hour) == nAlarmH && nCurrentTime.Minute == nAlarmM && nCurrentTime.Second <
             - 5)
 528   4                                              bSound = 1;
 529   4                              }  // Time Changed
 530   3      
 531   3                              PreDisplay ();
 532   3      
 533   3                      }       // Per 100 MS
 534   2              }       // Per 10 MS
 535   1      
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 10  

 536   1      
 537   1              if (nMode == MODE_CLOCK && nSubMode == SMODE_CLOCK && bNightMode && (( bSleep && !nSubModeTime) ||
 538   1                       (bNight && nShowCount < 10)))
 539   1              {
 540   2                      // Hide Display
 541   2                      P37 = 1;
 542   2                      P36 = 1;
 543   2                      P35 = 1;
 544   2                      P34 = 1;
 545   2              }
 546   1              else if (nShowCount >= 10)
 547   1              {
 548   2                      // Display
 549   2                      nShowCount = 0;
 550   2              
 551   2                      switch (nLED)
 552   2                      {
 553   3                      case 0:
 554   3                              P34 = 1;
 555   3                              if (nShow & 0x1)
 556   3                              {
 557   4                                      P2 = nData0;
 558   4                                      P37 = 0; //Lighton LED
 559   4                              }
 560   3                              nLED ++;
 561   3                              break;
 562   3                      case 1:
 563   3                              P37 = 1;
 564   3                              if (nShow & 0x2)
 565   3                              {
 566   4                                      P2 = nData1;
 567   4                                      P36 = 0;
 568   4                              }
 569   3                              nLED ++;
 570   3                              break;
 571   3                      case 2:
 572   3                              P36 = 1;
 573   3                              if (nShow & 0x4)
 574   3                              {
 575   4                                      P2 = nData2;
 576   4                                      P35 = 0;
 577   4                              }
 578   3                              nLED ++;
 579   3                              break;
 580   3                      case 3:
 581   3                              P35 = 1;
 582   3                              if (nShow & 0x8)
 583   3                              {
 584   4                                      P2 = nData3;
 585   4                                      P34 = 0;
 586   4                              }
 587   3                              nLED = 0;
 588   3                              break;
 589   3                      }
 590   2              }
 591   1      }
 592          
 593          
 594          void Delay10ms()
 595          {
 596   1              unsigned char n10MsSave, nMsSave;
 597   1      
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 11  

 598   1              n10MsSave = n10Ms;
 599   1              nMsSave = nMs;
 600   1              while (n10Ms == n10MsSave);
 601   1              n10MsSave = n10Ms;
 602   1              while (nMsSave != nMs && n10Ms == n10MsSave);
 603   1      }
 604          
 605          void HourInc ()
 606          {
 607   1              unsigned char nHour;
 608   1      
 609   1              nHour = nCurrentTime.Hour;
 610   1      
 611   1              if (nHour & 0x80) // 12 Hour mode
 612   1              {
 613   2                      if ((nHour & 0xA0) == 0xA0)     //PM
 614   2                      {
 615   3                              nHour = GETBCD (nHour & 0x1F);
 616   3                              if (nHour != 12) //12 PM means 12 aclock
 617   3                                      nHour += 12;
 618   3                      }
 619   2                      else                                       //AM
 620   2                      {
 621   3                              nHour = GETBCD (nHour & 0x1F);
 622   3                              if (nHour == 12)                        //12 AM means 0 aclock
 623   3                                      nHour = 0;
 624   3                      }
 625   2      
 626   2                      if (++nHour > 23)
 627   2                              nCurrentTime.Hour = 0x92;               //12AM
 628   2                      else if (nHour >= 12)                           //PM
 629   2                      {
 630   3                              nHour -= 12;
 631   3                              if (nHour == 0)
 632   3                                      nCurrentTime.Hour = 0xB2;       //12 PM
 633   3                              else
 634   3                                      nCurrentTime.Hour = 0xA0 | MAKEBCD (nHour);
 635   3                      }
 636   2                      else
 637   2                              nCurrentTime.Hour = 0x80 | MAKEBCD (nHour);
 638   2              }
 639   1              else
 640   1              {
 641   2                      nHour = GETBCD (nHour);
 642   2                      if (++nHour > 23)
 643   2                              nHour = 0;
 644   2                      nCurrentTime.Hour = MAKEBCD (nHour);
 645   2              }
 646   1      }
 647          
 648          void HourDec ()
 649          {
 650   1              unsigned char nHour;
 651   1      
 652   1              nHour = nCurrentTime.Hour;
 653   1      
 654   1              if (nHour & 0x80) // 12 Hour mode
 655   1              {
 656   2                      if ((nHour & 0xA0) == 0xA0)     //PM
 657   2                      {
 658   3                              nHour = GETBCD (nHour & 0x1F);
 659   3                              if (nHour != 12) //12 PM means 12 aclock
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 12  

 660   3                                      nHour += 12;
 661   3                      }
 662   2                      else                                       //AM
 663   2                      {
 664   3                              nHour = GETBCD (nHour & 0x1F);
 665   3                              if (nHour == 12)                        //12 AM means 0 aclock
 666   3                                      nHour = 0;
 667   3                      }
 668   2      
 669   2                      if (nHour > 0)
 670   2                              nHour --;
 671   2                      else
 672   2                              nHour = 23;
 673   2      
 674   2                      if (nHour == 0)
 675   2                              nCurrentTime.Hour = 0x92;               //12AM
 676   2                      else if (nHour >= 12)                           //PM
 677   2                      {
 678   3                              nHour -= 12;
 679   3                              if (nHour == 0)
 680   3                                      nCurrentTime.Hour = 0xB2;       //12 PM
 681   3                              else
 682   3                                      nCurrentTime.Hour = 0xA0 | MAKEBCD (nHour);
 683   3                      }
 684   2                      else
 685   2                              nCurrentTime.Hour = 0x80 | MAKEBCD (nHour);
 686   2              }
 687   1              else
 688   1              {
 689   2                      nHour = GETBCD (nHour);
 690   2      
 691   2                      if (nHour > 0)
 692   2                              nHour --;
 693   2                      else
 694   2                              nHour = 23;
 695   2                      nCurrentTime.Hour = MAKEBCD (nHour);
 696   2              }
 697   1      }
 698          
 699          unsigned char BCDInc (unsigned char nBCD, unsigned char nBCDLimit, unsigned char nBCDLow)
 700          {
 701   1              if (nBCD >= nBCDLimit || nBCD == 0x99)
 702   1                      return nBCDLow;
 703   1      
 704   1              if ((nBCD & 0xF) == 9)
 705   1                      return (nBCD & 0xF0) + 0x10;
 706   1              return (nBCD + 1);
 707   1      }
 708          
 709          unsigned char BCDDec (unsigned char nBCD, unsigned char nBCDLimit, unsigned char nBCDLow)
 710          {
 711   1              if (nBCD <= nBCDLow || nBCD == 0)
 712   1                      return nBCDLimit;
 713   1      
 714   1              if ((nBCD & 0xF) == 0)
 715   1                      return nBCD - 0x7; //0x10 + 0x9
 716   1              return (nBCD - 1);
 717   1      }
 718          
 719          void AdjustTime (bit bIncrease)
 720          {
 721   1              bit bModeChange = 0;
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 13  

 722   1      
 723   1              bBlockClock = 1;
 724   1      
 725   1              switch (nMode)
 726   1              {
 727   2              case MODE_HOUR:
 728   2                      if (bIncrease)
 729   2                              HourInc ();
 730   2                      else
 731   2                              HourDec ();
 732   2                      break;
 733   2              case MODE_MINUTE:
 734   2                      if (bIncrease)
 735   2                              nCurrentTime.Minute = BCDInc (nCurrentTime.Minute, 0x59, 0);
 736   2                      else
 737   2                              nCurrentTime.Minute = BCDDec (nCurrentTime.Minute, 0x59, 0);
 738   2                      nCurrentTime.Second = 0;
 739   2                      break;
 740   2              case MODE_MONTH:
 741   2                      if (bIncrease)
 742   2                              nCurrentTime.Month = BCDInc (nCurrentTime.Month, 0x12, 1);
 743   2                      else
 744   2                              nCurrentTime.Month = BCDDec (nCurrentTime.Month, 0x12, 1);
 745   2                      break;
 746   2              case MODE_DAY:
 747   2                      if (bIncrease)
 748   2                              nCurrentTime.Day = BCDInc (nCurrentTime.Day, tblMonthDays[nCurrentTime.Month] + (nCurrentTime.Month == 
             -2 && (GETBCD(nCurrentTime.Year) % 4) == 0), 1);
 749   2                      else
 750   2                              nCurrentTime.Day = BCDDec (nCurrentTime.Day, tblMonthDays[nCurrentTime.Month] + (nCurrentTime.Month == 
             -2 && (GETBCD(nCurrentTime.Year) % 4) == 0), 1);
 751   2                      break;
 752   2              case MODE_WEEK:
 753   2                      if (bIncrease)
 754   2                              nCurrentTime.Week = BCDInc (nCurrentTime.Week, 7, 1);
 755   2                      else
 756   2                              nCurrentTime.Week = BCDDec (nCurrentTime.Week, 7, 1);
 757   2                      break;
 758   2              case MODE_YEAR:
 759   2                      if (bIncrease)
 760   2                              nCurrentTime.Year = BCDInc (nCurrentTime.Year, 0x99, 0);
 761   2                      else
 762   2                              nCurrentTime.Year = BCDDec (nCurrentTime.Year, 0x99, 0);
 763   2                      break;
 764   2              case MODE_HOUR24:
 765   2                      if (nCurrentTime.Hour & 0x80)   // 12 HOUR
 766   2                              nCurrentTime.Hour = BCDHour24 (nCurrentTime.Hour);
 767   2                      else
 768   2                              nCurrentTime.Hour = BCDHour12 (nCurrentTime.Hour);
 769   2                      break;
 770   2              case MODE_ALARM_H:
 771   2                      if (bIncrease)
 772   2                              nAlarmH = BCDInc (nAlarmH, 0x23, 0);
 773   2                      else
 774   2                              nAlarmH = BCDDec (nAlarmH, 0x23, 0);
 775   2                      DS1302WriteMyData (2, nAlarmH);
 776   2                      bBlockClock = 0;
 777   2                      return;
 778   2              case MODE_ALARM_M:
 779   2                      if (bIncrease)
 780   2                              nAlarmM = BCDInc (nAlarmM, 0x59, 0);
 781   2                      else
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 14  

 782   2                              nAlarmM = BCDDec (nAlarmM, 0x59, 0);
 783   2                      DS1302WriteMyData (3, nAlarmM);
 784   2                      bBlockClock = 0;
 785   2                      return;
 786   2              case MODE_BEEP:
 787   2                      bBeep = !bBeep;
 788   2                      bModeChange = 1;
 789   2                      break;
 790   2              case MODE_UP:
 791   2                      bUp = !bUp;
 792   2                      bModeChange = 1;
 793   2                      break;
 794   2              case MODE_NIGHT:
 795   2                      bNightMode = !bNightMode;
 796   2                      bModeChange = 1;
 797   2                      break;
 798   2      
 799   2              default:
 800   2                      bBlockClock = 0;
 801   2                      return;
 802   2              }
 803   1      
 804   1              if (bModeChange)
 805   1              {
 806   2                      DS1302WriteMyData (1, (unsigned char)bBeep | ((unsigned char)bUp << 1) | ((unsigned char)bNightMode << 2
             -));
 807   2                      bBlockClock = 0;
 808   2                      return;
 809   2              }
 810   1              DS1302WriteTime (&nCurrentTime);//Write Time
 811   1              n100Ms = 0;
 812   1              n10Ms = 0;
 813   1              nMs = 0;
 814   1              bBlockClock = 0;
 815   1      }
 816          
 817          void InitTimer ()
 818          {
 819   1              unsigned char nMyData;
 820   1      
 821   1              bBlockClock = 1;
 822   1      
 823   1              bDot = 0;
 824   1              n100Ms = 0;
 825   1              n10Ms = 0;
 826   1              nMs = 0;
 827   1              nLED = 0;
 828   1      
 829   1              ClockInit ();
 830   1      
 831   1              nMyData = DS1302ReadMyData (1);
 832   1              bBeep = nMyData & 0x1;
 833   1              bUp = (nMyData & 0x2);
 834   1              bNightMode = (nMyData & 0x4);
 835   1              nAlarmH = DS1302ReadMyData (2);
 836   1              nAlarmM = DS1302ReadMyData (3);
 837   1              nAlarmH = (nAlarmH >= 24) ? 0 : nAlarmH;
 838   1              nAlarmM = (nAlarmM >= 60) ? 0 : nAlarmM;
 839   1      
 840   1      //      DS1302ReadTime (&nCurrentTime);
 841   1      //      PreDisplay ();
 842   1      
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 15  

 843   1              bBlockClock = 0;
 844   1      
 845   1              AUXR |= 0x80;           // 1T mode
 846   1              TL0 = 0xCD;
 847   1              TH0 = 0xD4;                     // 1ms
 848   1              TMOD = 1;                       // Timer Mode
 849   1              TCON = 0x10;            // Timer
 850   1              IE = 0x82;                      // INT
 851   1      }
 852          
 853          void main()
 854          {
 855   1              unsigned char nPressedSec, nPressedMs, nDiffMs, nLimitMs;
 856   1              bit bIncrease;
 857   1      
 858   1              nTemp = ReadTemperature (&nTempL);
 859   1              InitTimer ();
 860   1      
 861   1              BEEP = 1;
 862   1              nMode = 0;
 863   1              bPressedS1 = 0;
 864   1              bPressedS2 = 0;
 865   1              bIncrease = 1;
 866   1      
 867   1      
 868   1              while (1)
 869   1              {
 870   2                      if (!KEY_S1)
 871   2                      {
 872   3                              Delay10ms ();
 873   3                              if (!KEY_S1)
 874   3                              {
 875   4                                      if (nMode == MODE_CLOCK)
 876   4                                      {
 877   5                                              while (!KEY_S1);
 878   5      
 879   5                                              if (nSubMode != SMODE_CLOCK || !bSleep || nSubModeTime) //Not Sleep
 880   5                                                      if (++nSubMode > SMODE_MAX)
 881   5                                                              nSubMode = 0;
 882   5                                              if (nSubMode == SMODE_COUNTDOWN1)
 883   5                                              {
 884   6                                                      nCountDownMin = 1;
 885   6                                                      nCountDownSec = 0;
 886   6                                                      nCountDownBeep = 3;
 887   6                                              }
 888   5                                              bSound = 1;
 889   5                                              nSubModeTime = SMODE_COUNTSEC;
 890   5                                      }
 891   4                                      else
 892   4                                      {
 893   5                                              nLimitMs = 20;  //1.5sec
 894   5                                              nPressedSec = nCurrentTime.Second;
 895   5                                              nPressedMs = n100Ms;
 896   5                                              bPressedS1 = 0;
 897   5                                              while (!KEY_S1)
 898   5                                              {                               
 899   6                                                      if (!KEY_OK)    // Press OK & S1
 900   6                                                      {
 901   7                                                              while (!KEY_OK || !KEY_S1);     //Until all released
 902   7                                                              bIncrease = !bIncrease;
 903   7                                                              break;
 904   7                                                      }
C51 COMPILER V7.10   MAIN                                                                  01/07/2017 22:49:10 PAGE 16  

 905   6      
 906   6                                                      nDiffMs = (((nCurrentTime.Second < nPressedSec) ? 60 : 0) + nCurrentTime.Second - nPressedSec) * 10 
             -+ ((nCurrentTime.Second == nPressedSec && n100Ms < nPressedMs) ? 10 : 0) + n100Ms - nPressedMs;
 907   6                                                      //nDiffMs = 0.1sec
 908   6              
 909   6                                                      if (nDiffMs > nLimitMs)
 910   6                                                      {
 911   7                                                              AdjustTime (bIncrease);
 912   7                                                              bPressedS1 = 1;
 913   7                                                              nPressedSec = nCurrentTime.Second;
 914   7                                                              nPressedMs = n100Ms;
 915   7                                                              nLimitMs = 5;  //0.3 sec
 916   7                                                              bSound = 1;
 917   7                                                      }
 918   6                                              }
 919   5                                              if (!bPressedS1) //Single Click
 920   5                                              {
 921   6                                                      AdjustTime (bIncrease);
 922   6                                                      bSound = 1;
 923   6                                              }
 924   5                                              else
 925   5                                                      bPressedS1 = 0;
 926   5                                      }
 927   4                              }
 928   3                      }
 929   2                      if (!KEY_OK)
 930   2                      {
 931   3                              Delay10ms ();
 932   3                              if (!KEY_OK)
 933   3                              {
 934   4                                      while (!KEY_OK);
 935   4      
 936   4                                      // Press S2
 937   4                                      if (++nMode > MODE_MAX)
 938   4                                      {
 939   5                                              nMode = 0;
 940   5                                              nSubMode = 0;
 941   5                                      }
 942   4                                      bIncrease = 1;  //Reset to Increasing
 943   4                                      bSound = 1;
 944   4                              }
 945   3                      }
 946   2              }
 947   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2788    ----
   CONSTANT SIZE    =    155    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     29       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     10       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
